### This file has been autogenerated from maid_tools.ipynb on 04/01/2023 06:19:26 ###

__all__ = ['AttentionPool2d','clean_mem','get_dls_infer', 'plot_img', 'plot_points', 'df_to_xy_anim','plot_img_seq']

from fastai.data.all import *
from fastai.vision.all import *
import fastai.distributed  # with learn.parallel_ctx(): learn.fit(.....)
import torch as tc
import gc, traceback
from tqdm.notebook import tqdm
# from shape_model import * -> temporarily commented out by RANTI



# ignore learner warnings
import warnings
warnings.filterwarnings("ignore", message="The parameter 'pretrained' is deprecated")
warnings.filterwarnings("ignore", message="Arguments other than a weight enum or")

def clean_mem():
    
    # clean traceback
    if hasattr(sys, 'last_traceback'):
        traceback.clear_frames(sys.last_traceback)
        delattr(sys, 'last_traceback')
    if hasattr(sys, 'last_type'): delattr(sys, 'last_type')
    if hasattr(sys, 'last_value'): delattr(sys, 'last_value')    

    # clean_ipython_history - code in this function mainly copied from IPython source
    if 'get_ipython' in globals():
        ip = get_ipython()
        user_ns = ip.user_ns
        ip.displayhook.flush()
        pc = ip.displayhook.prompt_count + 1
        for n in range(1, pc): user_ns.pop('_i'+repr(n),None)
        user_ns.update(dict(_i='',_ii='',_iii=''))
        hm = ip.history_manager
        hm.input_hist_parsed[:] = [''] * pc
        hm.input_hist_raw[:] = [''] * pc
        hm._i = hm._ii = hm._iii = hm._i00 =  ''
    
    # standard stuff
    gc.collect()
    torch.cuda.empty_cache()


def get_dls_infer(all_files, resolution, bs=16, num_workers=None, pad_mode=PadMode.Reflection, **kwargs):
    block_infer = DataBlock(
        blocks=(ImageBlock),#, PointBlock),
        get_items=lambda _: all_files,
        splitter=None, #IndexSplitter(val_ixs),
        # item_tfms = Resize(512),
        # batch_tfms=[*aug_transforms(size=(512,512),pad_mode=pad_mode, **kwargs), 
                    # Normalize.from_stats(*imagenet_stats)]
        batch_tfms=[*aug_transforms(pad_mode=pad_mode, **kwargs), 
                    Normalize.from_stats(*imagenet_stats)]
    )
    dls = block_infer.dataloaders(None, bs=bs, num_workers=num_workers)
    return dls,block_infer


class AttentionPool2d(nn.Module):
  def __init__(self, C, d_model, n_out) -> None:
    super().__init__()
    self.d_model,self.n_out = tc.tensor(d_model),n_out
    self.Xq = nn.Parameter(tc.randn(n_out, C)   / tc.tensor(C).sqrt())
    self.Wq = nn.Parameter(tc.randn(C, d_model) / tc.tensor(C).sqrt())
    self.Wk = nn.Parameter(tc.randn(C, d_model) / tc.tensor(C).sqrt())
    self.Wv = nn.Parameter(tc.randn(C, d_model) / tc.tensor(C).sqrt())

  def forward(self, x):
    B,C,H,W = x.shape
    x = x.view(B,C,-1).permute(0,2,1) # BxCxHxW -> BxHWxC
    Q = self.Xq @ self.Wq  #  n_out x d_model
    K = x @ self.Wk        # B x HW x d_model
    V = x @ self.Wv        # B x HW x d_model
    attn = F.softmax(Q @ K.permute(0,2,1) / self.d_model.sqrt(), -1) @ V
    return attn.permute(0,2,1).contiguous()


###DICTIONARIES:

selector_dict = {
"study"     : ["NS", "RS"], #normative study or repeatability study
"spine"     : ["L","C","O"],
"experiment": ["WB_FLEX", "WB_EXT","REC_FLEX","REC_EXT"],
"lumbar"    : ["T12", "L1", "L2", "L3", "L4", "L5", "SAC", "ILI", "OTH"], # SAC for SACRUM, ILI for ILIUM, OTH for OTHER
"coord_axis": ["X", "Y"],
"bb_corner" : ["TL", "BL", "BR", "TR"] ## anti-clockwise starting from topleft (TL) corner
}

experiment_dict = {
    "WB_FLEX"  : 0, # Flexion Weight Bearing
    "WB_EXT"   : 1,
    "REC_FLEX" : 2,
    "REC_EXT"  : 3 # Extension recumbant
}

spine_dict = {
    "L" : 0, #lumbar
    "C" : 1, #neck
    "O" : 2 #other
}

lumbar_dict = { # vertebra
    "T12" : 0,
    "L1"  : 1,
    "L2"  : 2,
    "L3"  : 3,
    "L4"  : 4,
    "L5"  : 5,
    "SAC" : 6,
    "ILI" : 7,
    "OTH" : 8
}

startVertebra = "L2"

import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

##plottter functions with plotly
def plot_img(img, img_name, show = False):
    
    img_to_plot = img
    width_multiplier = 1
    
    if len(img.shape) > 2: ## if there are more than 1 channel
        width_multiplier = img.shape[0] ## because in pytorch the first shape element denotes channels
        for i in range(img.shape[0]):
            if i== 0:
                img_to_plot = img[i,:,:]
            else:
                img_to_plot = np.hstack((img_to_plot, img[i,:,:]))
        
    trace = go.Heatmap(
        x = np.array(range(img_to_plot.shape[0])),
        y = np.array(range(img_to_plot.shape[1])),
        z = img_to_plot, ## 3 identical 
        type = 'heatmap',
        colorscale = 'gray',
        name = img_name
    )
    
    fig = go.Figure(
        data = [trace]
    )

    fig.update_layout(title_text = img_name, title_y = 0.85, width=512*width_multiplier, height= 512, autosize = False)
    fig.update_yaxes(autorange='reversed', scaleanchor='x', constrain='domain') #https://github.com/plotly/plotly.py/issues/2885
    fig.update_xaxes(constrain='domain')

    if show:
        fig.show()
    return fig

def plot_points(fig, img_size, x, y, series_name = "gold", show = False):  
    print("entering plot points function")
    if fig == 'new':
        fig = go.Figure()
        fig.update_layout(title_text = series_name, title_y = 0.85, width = 512, height = 512, autosize = False, plot_bgcolor = 'black')
        fig.update_yaxes(autorange='reversed', scaleanchor='x')#, constrain='domain') #https://github.com/plotly/plotly.py/issues/2885
    
    if ("gold" in series_name) or ("pred" in series_name) or ("filt" in series_name):
        if ("gold" in series_name):
            colour = "yellow"#px.colors.qualitative.Plotly[9] ## gold pallet from here: https://plotly.com/python/discrete-color/#:~:text=5%20total_bill%20tip-,Color%20Sequences%20in%20Plotly%20Express,color%20sequences%20from%20the%20px.
            leg_group = "GOLD"
        elif ("filt" in series_name):
            colour = "green"#px.colors.qualitative.Plotly[9] ## gold pallet from here: https://plotly.com/python/discrete-color/#:~:text=5%20total_bill%20tip-,Color%20Sequences%20in%20Plotly%20Express,color%20sequences%20from%20the%20px.
            leg_group = "FILT"
        else:
            # colour = px.colors.qualitative.Plotly#[0] ## purpley bluey
            colour = px.colors.sequential.matter#YlOrRd#.diverging.RdYlBu#[0] ## purpley bluey
            leg_group = "PRED"

    x_rescaled = x*img_size[0]
    y_rescaled = y*img_size[1]
    
    if (len(x_rescaled.shape) == 1) and (x_rescaled.shape[0] > 4):
        div = x_rescaled.shape[0] % 4
        if div != 0:
            x_rescaled = np.concatenate([x_rescaled, [x_rescaled[-1],x_rescaled[-1]]])
            y_rescaled = np.concatenate([y_rescaled, [y_rescaled[-1],y_rescaled[-1]]])

        x_rescaled = x_rescaled.reshape(-1,4) #split into vertebra
        y_rescaled = y_rescaled.reshape(-1,4) # split into vertera
        no_of_vertebra = x_rescaled.shape[0]
        start_vert_no = lumbar_dict[startVertebra]

        for i in range(no_of_vertebra):
            fig.add_trace(
                go.Scatter(
                    mode = 'markers',
                    name = selector_dict["lumbar"][i+start_vert_no]+"_"+series_name,
                    x = x_rescaled[i],
                    y = y_rescaled[i],
                    # fill="toself",
                    legendgroup = selector_dict["lumbar"][i+start_vert_no]+"_"+series_name,
                    # opacity=0.45,
                    marker=dict(
                        color = colour[i*2+1]
                    )
                )
            )
            fig.add_trace(
                go.Scatter(
                    mode = 'markers',
                    name = selector_dict["lumbar"][i+start_vert_no]+"_"+series_name,
                    x = x_rescaled[i],
                    y = y_rescaled[i],
                    showlegend = False,
                    fill="toself",
                    legendgroup = selector_dict["lumbar"][i+start_vert_no]+"_"+series_name,
                    opacity=0.4,
                    marker=dict(
                        color = colour[i*2+1]
                    )
                )
            )

    else:
        fig.add_trace(
                go.Scatter(
                    mode = 'markers',
                    name = series_name,
                    fill="toself",
                    opacity=0.65,
                    x = x_rescaled,
                    y = y_rescaled,#,
                    marker=dict(
                    color = colour
                    )
                )
            )

    print(x_rescaled.shape, x_rescaled)
     
    fig. update_layout(
        legend=dict(
                orientation = 'h'
            )
        )

    if show == True:
        fig.show()
    return fig

def df_to_xy_anim(df_raw): 
    """
    FOR XY animation
    points returned as normalised coordinates
    """
    df = df_raw.iloc[:, 2:] ## only select all columns from 'Frame' onwards
    
    df_x = df.drop(columns = df.filter(like="Y", axis=1).columns)
    df_y = df.drop(columns = df.filter(like="X", axis=1).columns)

    df_x.iloc[:, 1:] = df_x.iloc[:, 1:]/1024.0 ##normalises points
    df_y.iloc[:, 1:] = df_y.iloc[:, 1:]/1024.0 ##normalises points

    ##.melt pivots data into a table from wide to long
    df_y_anim = df_y.melt(id_vars='Frame').sort_values(by = 'Frame')
    df_x_anim = df_x.melt(id_vars= 'Frame').sort_values(by = 'Frame')
   
    return df_x_anim, df_y_anim ##returns normalised points

def plot_img_seq(img_seq, coord_seq, coord_seq_pred = "empty", name1 = "seq1", name2 = "seq2", colour1 = "gold", colour2 = "blue"):
    """
    loads and plots patient sequence in image recording
    coord_seq = dataframe of one patient
    need to use pd.melt
    """

    pcode = pd.unique(coord_seq.PatientCode)
    experiment = pd.unique(coord_seq.Experiment)
    img_seq = np.array(img_seq)
    img_size = img_seq[0].shape

    
    custom_layout = go.Layout(
        title_text = str(pcode+"_"+experiment),
        autosize = False,
        width = img_size[0]*2,
        height = img_size[1]*2,
        showlegend = True
    )
    
    #load this to get images fast, then later use the source value in go.Image
    fig0 = px.imshow(img_seq, animation_frame=0, binary_string=True, labels=dict(animation_frame="frame"))
    
    
    df_x_norm, df_y_norm = df_to_xy_anim(coord_seq)
    
    

    frame_nos = pd.unique(df_x_norm.Frame) # frame numbers
    # frame_nos = frame_nos[:10]#to make testing and loading faster

    print("FIG0: ", fig0.frames[0])

    # x_norm = df_x_norm[df_x_norm.Frame == 1].value.to_numpy() 
    # y_norm = df_y_norm[df_y_norm.Frame == 1].value.to_numpy() 

    # x2_norm = df_x_norm[df_x2_norm.Frame == 1].value.to_numpy() 
    # y2_norm = df_y_norm[df_y2_norm.Frame == 1].value.to_numpy() 

    # x = x_norm * img_size[0]
    # y = y_norm * img_size[1]
    
    if type(coord_seq_pred) is pd.core.frame.DataFrame:
        df_x2_norm, df_y2_norm = df_to_xy_anim(coord_seq_pred)

        frames = [
            go.Frame(
                data = [
                    go.Image(
                        source = fig0.frames[frame_no].data[0]['source']
                    ),
                    go.Scatter(
                        x = df_x_norm[df_x_norm.Frame == frame_no].value.to_numpy() * img_size[0],
                        y = df_y_norm[df_y_norm.Frame == frame_no].value.to_numpy() * img_size[1],
                        ids = df_x_norm[df_x_norm.Frame == frame_no].variable,
                        name = name1,
                        mode='markers',
                        marker_color = colour1,
                        showlegend=True
                    ),
                    go.Scatter(
                        x = df_x2_norm[df_x2_norm.Frame == frame_no].value.to_numpy() * img_size[0],
                        y = df_y2_norm[df_y2_norm.Frame == frame_no].value.to_numpy() * img_size[1],
                        ids = df_x2_norm[df_x2_norm.Frame == frame_no].variable,
                        name = name2,
                        mode='markers',
                        marker_color = colour2,
                        showlegend=True
                    )
                ],
                name = str(frame_no)

            )
            for i, frame_no in enumerate(frame_nos)
        ]

        fig1 = go.Figure(
            data = [
                go.Image(
                        source = fig0.frames[0].data[0]['source']
                ),
                go.Scatter(
                            x = df_x_norm[df_x_norm.Frame == 0].value.to_numpy() * img_size[0],
                            y = df_y_norm[df_y_norm.Frame == 0].value.to_numpy() * img_size[1],
                            ids = df_x_norm[df_x_norm.Frame == 0].variable,
                            name = name1,
                            mode='markers',
                            marker_color = colour1,
                            showlegend=True
                        ),
                go.Scatter(
                            x = df_x2_norm[df_x2_norm.Frame == 0].value.to_numpy() * img_size[0],
                            y = df_y2_norm[df_y2_norm.Frame == 0].value.to_numpy() * img_size[1],
                            ids = df_x2_norm[df_x2_norm.Frame == 0].variable,
                            name = name2,
                            mode='markers',
                            marker_color = colour2,
                            showlegend=True
                        )
            ],
            frames = frames,
            layout = custom_layout

        )
    
    else: ## if only 1 plot
        frames = [
            go.Frame(
                data = [
                    go.Image(
                        source = fig0.frames[frame_no].data[0]['source']
                    ),
                    go.Scatter(
                        x = df_x_norm[df_x_norm.Frame == frame_no].value.to_numpy() * img_size[0],
                        y = df_y_norm[df_y_norm.Frame == frame_no].value.to_numpy() * img_size[1],
                        ids = df_x_norm[df_x_norm.Frame == frame_no].variable,
                        name = name1,
                        mode='markers',
                        marker_color = colour1,
                        showlegend=True
                    )
                ],
                name = str(frame_no)

            )
            for i, frame_no in enumerate(frame_nos)
        ]

        fig1 = go.Figure(
            data = [
                go.Image(
                        source = fig0.frames[0].data[0]['source']
                ),
                go.Scatter(
                            x = df_x_norm[df_x_norm.Frame == 0].value.to_numpy() * img_size[0],
                            y = df_y_norm[df_y_norm.Frame == 0].value.to_numpy() * img_size[1],
                            ids = df_x_norm[df_x_norm.Frame == 0].variable,
                            name = name1,
                            mode='markers',
                            marker_color = colour1,
                            showlegend=True
                )
            ],
            frames = frames,
            layout = custom_layout

        )

    fig1.update_xaxes(range=[0,img_size[0]], autorange = False)
    fig1.update_yaxes(range=[img_size[1],0], autorange = False)

    updmenus = [
        {
            "args": [
                None,
                {"frame": {"duration": 70, "redraw": True}}
            ],
            "label": "&#9654;","method": "animate" # play button action
        },
        {
            'args': [
                [None],
                {'frame': {'duration': 0}, 'mode': 'immediate', 'fromcurrent': True}
            ],
            'label': '&#9724;', 'method': 'animate' #stop button action
        }

    ]   

    fig1.update_layout(
        updatemenus=[{"buttons":updmenus}]
    )


    return fig1
